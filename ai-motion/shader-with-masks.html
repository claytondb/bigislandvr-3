<!DOCTYPE html>
<html>
<head>
    <title>Shader Animation with AI Masks</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1a1a; color: white; font-family: system-ui, sans-serif; overflow: hidden; }
        #container { width: 100vw; height: 100vh; }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            width: 280px;
            z-index: 100;
        }
        h2 { margin-bottom: 15px; font-size: 1.1rem; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.85rem; color: #aaa; }
        input[type="range"] { width: 100%; }
        .value { float: right; color: #7fcdcd; }
        .info { 
            position: fixed; 
            bottom: 20px; 
            left: 20px; 
            background: rgba(0,0,0,0.8); 
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        .location-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #333;
            border: none;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            font-size: 0.9rem;
        }
        .location-btn:hover { background: #444; }
        .location-btn.active { background: #2a9d8f; }
        .badge { background: #0d3b66; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 5px; }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h2>üé® Shader + AI Masks</h2>
        
        <div class="control-group">
            <label>‚òÅÔ∏è Cloud Drift <span class="value" id="sky-val">100%</span></label>
            <input type="range" id="sky" min="0" max="100" value="100">
        </div>
        
        <div class="control-group">
            <label>üåä Water Ripples <span class="value" id="water-val">50%</span></label>
            <input type="range" id="water" min="0" max="100" value="50">
        </div>
        
        <div class="control-group">
            <label>üåø Vegetation Sway <span class="value" id="veg-val">30%</span></label>
            <input type="range" id="veg" min="0" max="100" value="30">
        </div>
        
        <hr style="border-color: #333; margin: 15px 0;">
        
        <label>Location:</label>
        <button class="location-btn active" data-loc="alii-drive">üèñÔ∏è Ali'i Drive <span class="badge">WITH MASKS</span></button>
        <button class="location-btn" data-loc="hilo-bayfront">üåä Hilo Bayfront <span class="badge">WITH MASKS</span></button>
        <button class="location-btn" data-loc="punaluu-beach">üê¢ Punalu'u Beach <span class="badge">WITH MASKS</span></button>
        <button class="location-btn" data-loc="keaau">üìç Kea ªau <span class="badge">WITH MASKS</span></button>
    </div>
    
    <div class="info">
        <strong>‚ú® Now using AI-generated masks!</strong><br>
        Effects only apply to actual sky/water/vegetation regions.
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        const fragmentShader = `
            uniform sampler2D panorama;
            uniform sampler2D skyMask;
            uniform sampler2D waterMask;
            uniform sampler2D vegMask;
            uniform float time;
            uniform float skyIntensity;
            uniform float waterIntensity;
            uniform float vegIntensity;
            varying vec2 vUv;
            
            // Noise
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i = floor(v + dot(v, C.yy));
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m; m = m*m;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                vec3 g;
                g.x = a0.x * x0.x + h.x * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
            
            void main() {
                vec2 uv = vUv;
                vec2 distortion = vec2(0.0);
                
                // Sample masks
                float sky = texture2D(skyMask, uv).r;
                float water = texture2D(waterMask, uv).r;
                float veg = texture2D(vegMask, uv).r;
                
                // Sky/cloud drift - very gentle
                if (sky > 0.1 && skyIntensity > 0.0) {
                    float drift = snoise(uv * 2.0 + time * 0.03) * 0.004;
                    float morph = snoise(uv * 3.0 + time * 0.05) * 0.003;
                    distortion += vec2(drift, morph * 0.3) * skyIntensity * sky;
                }
                
                // Water ripples
                if (water > 0.1 && waterIntensity > 0.0) {
                    float wave1 = sin(uv.x * 30.0 + time * 1.5) * 0.002;
                    float wave2 = sin(uv.y * 25.0 + time * 1.2) * 0.0015;
                    float ripple = snoise(uv * 15.0 + time * 0.5) * 0.003;
                    distortion += vec2(wave1 + ripple, wave2 + ripple) * waterIntensity * water;
                }
                
                // Vegetation sway
                if (veg > 0.1 && vegIntensity > 0.0) {
                    float sway = sin(time * 0.6 + uv.x * 10.0) * 0.003;
                    float rustle = snoise(uv * 12.0 + time * 0.4) * 0.002;
                    distortion += vec2(sway + rustle, rustle * 0.2) * vegIntensity * veg;
                }
                
                vec4 color = texture2D(panorama, uv + distortion);
                gl_FragColor = color;
            }
        `;
        
        let scene, camera, renderer, material;
        let isUserInteracting = false, lon = 0, lat = 0;
        let onPointerDownLon = 0, onPointerDownLat = 0, onPointerDownX = 0, onPointerDownY = 0;
        
        const settings = { skyIntensity: 1.0, waterIntensity: 0.5, vegIntensity: 0.3 };
        
        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            loadLocation('alii-drive');
            
            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerup', onPointerUp);
            container.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onResize);
            
            // Controls
            ['sky', 'water', 'veg'].forEach(type => {
                document.getElementById(type).addEventListener('input', (e) => {
                    settings[type + 'Intensity'] = e.target.value / 100;
                    document.getElementById(type + '-val').textContent = e.target.value + '%';
                });
            });
            
            document.querySelectorAll('.location-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadLocation(btn.dataset.loc);
                });
            });
            
            animate();
        }
        
        function loadLocation(loc) {
            const loader = new THREE.TextureLoader();
            
            Promise.all([
                new Promise(r => loader.load(`panoramas/${loc}.jpg`, r)),
                new Promise(r => loader.load(`masks/${loc}-sky.png`, r)),
                new Promise(r => loader.load(`masks/${loc}-water.png`, r)),
                new Promise(r => loader.load(`masks/${loc}-veg.png`, r))
            ]).then(([pano, sky, water, veg]) => {
                const oldMesh = scene.getObjectByName('panorama');
                if (oldMesh) scene.remove(oldMesh);
                
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        panorama: { value: pano },
                        skyMask: { value: sky },
                        waterMask: { value: water },
                        vegMask: { value: veg },
                        time: { value: 0 },
                        skyIntensity: { value: settings.skyIntensity },
                        waterIntensity: { value: settings.waterIntensity },
                        vegIntensity: { value: settings.vegIntensity }
                    },
                    vertexShader,
                    fragmentShader,
                    side: THREE.BackSide
                });
                
                const geometry = new THREE.SphereGeometry(500, 60, 40);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'panorama';
                scene.add(mesh);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (material) {
                material.uniforms.time.value = performance.now() / 1000;
                material.uniforms.skyIntensity.value = settings.skyIntensity;
                material.uniforms.waterIntensity.value = settings.waterIntensity;
                material.uniforms.vegIntensity.value = settings.vegIntensity;
            }
            lat = Math.max(-85, Math.min(85, lat));
            const phi = THREE.MathUtils.degToRad(90 - lat);
            const theta = THREE.MathUtils.degToRad(lon);
            camera.position.set(100 * Math.sin(phi) * Math.cos(theta), 100 * Math.cos(phi), 100 * Math.sin(phi) * Math.sin(theta));
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }
        
        function onPointerDown(e) { isUserInteracting = true; onPointerDownX = e.clientX; onPointerDownY = e.clientY; onPointerDownLon = lon; onPointerDownLat = lat; }
        function onPointerMove(e) { if (isUserInteracting) { lon = (onPointerDownX - e.clientX) * 0.1 + onPointerDownLon; lat = (e.clientY - onPointerDownY) * 0.1 + onPointerDownLat; } }
        function onPointerUp() { isUserInteracting = false; }
        function onWheel(e) { camera.fov = Math.max(30, Math.min(90, camera.fov + e.deltaY * 0.05)); camera.updateProjectionMatrix(); }
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        init();
    </script>
</body>
</html>
